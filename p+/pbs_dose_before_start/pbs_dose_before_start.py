#!/usr/bin/env python3

""" A module to parse the OUTPUT.tar.gz file generated by the TCS software system to look for
  dose collected on IC2/3 between the patient treatment start and the first layer treated.

  Usage:  pbs_dose_before_start.py /directory_to_OUTPUT.tar.gz files.
    ** If on Linux / Unix make sure to chmod +x the script before trying this.
"""
import os
import re
import sys
import tarfile
import datetime

class Treatment(object):
    """ A python class to objectify a a patient treatment capturing the patient id, room, start time, 
        and stop time of the field. """
    def __init__(self):
        """ Initialization of the Treatment objects. """
        self._room = None
        self._start_time = None
        self._stop_time = None
        self._patient_id = None

    @property
    def patient_id(self):
        return self._patient_id

    @patient_id.setter
    def patient_id(self, value):
        self._patient_id = value

    @property
    def room(self):
        return self._room

    @room.setter
    def room(self, value):
        self._room = value

    @property
    def start_time(self):
        return self._start_time

    @start_time.setter
    def start_time(self,value):
        self._start_time = value

    @property
    def stop_time(self):
        return self._stop_time

    @stop_time.setter
    def stop_time(self,value):
        self._stop_time = value

    def treatment_found(self):
        """ Treatment found is if all properties of the class have been defined.
            Args:
                self - the current object
            Returns:
                True if the treatment has all properties defined or False if not.
        """
        if self._patient_id and self._start_time and self._stop_time and self._room:
            return True
    
    def __repr__(self):
        return 'Patient: {}\n\tRoom {}\n\tStart {}:\n\tStop {}\n'.format(self.patient_id,
                                                                        self.room,
                                                                        self.start_time,
                                                                        self.stop_time)

def file_walker(directory):
    """" Walk a directory and yield all files in the directory.

    Args:
        directory: - Path of files to be walked through.

    Returns:
        A generator object that will yield each file in the directory when iterated over in a loop or next
    """
    for dirName, subdirList, file_list in os.walk(directory):
        for file_name in file_list:
            yield os.path.join(dirName, file_name)

def find_tar_gz_files(directory):
    """ Walks through a directory and finds all tarballs  *.tar.gz.

    Args:
        directory: - Path of files to be searched for tarballs.

    Returns:
        A generator object that will yield each tarball in a given directory structure.
    """
    normal_record = re.compile('tar.gz$')
    file_walk = file_walker(directory)
    for file in file_walk:
        if re.search(normal_record, file) is not None:
            yield file

def find_tar_files_in_tarball(tarball):
    """ Walks through a tarball file and finds all tar files inside.

    Args:
        tarball: - A tar file

    Returns:
        A generator object that will yield each file in a given tarball.
    """
    tar_files = re.compile('.tar$')
    with tarfile.open(tarball, "r") as f:
        for item in f.getmembers():
            if re.search(tar_files, item.name) is not None:
                file = f.extractfile(item)
                yield file

def find_process_log_file(tarfileobject, search_string):
    """ Goes through list of files in a tar file and finds a process log file with a name
    that matches the search_string pattern.
    
    Args:
        tarfileobject:  A tarfileobject that contains treatment process logs.
         
    Returns:
        A file of the given search string found in a tar file.
    """
    treatment_process = re.compile(search_string)
    for item in tarfileobject.getmembers():
        if re.search(treatment_process, item.name) is not None:
            log = tarfileobject.extractfile(item)
            yield log 

def parse_treatment_file(log, room):
    """ Parse a treatment process log file with the given room number.
    
    Args:
        log: A pts-treat-process log file.

    Returns:
        A list of Treatment objects.
    """

    
    treatments = []  # Empty list to of treatments
    treatment =  Treatment()
    treatment.room = room
    # Go through each line of a treatment process log. 
    for rawline in log:
        line = rawline.decode('utf-8','strict') # Since the data is in a compressed file, have to decode.
        # Has a patient been loaded and is this a patient being loaded line.
        # Each patient load line starts a new field.
        if treatment.patient_id is None:
            treatment.patient_id = parse_patient_id(line)
            continue  # Very important to short circuit the for-loop, to make it faster.

        # Check to see if a patient is cancelled.
        if is_cancel(line):
            patient_id = None
            treatment.start_time = None
            treatment.stop_time = None
            continue

        # A patient has been loaded, but there is no recorded start time yet. 
        if treatment.patient_id and treatment.start_time is None:
            # Start time will stay None until a line is found.
            treatment.start_time = find_event_line('Activity Controller BeamAccessPointBssController activity ENABLE_BEAM: IDLE -> ONGOING.', line) 
            continue # Very important to short circuit the for-loop, to make it faster.

        # Look for abnormal beam detection in the treatment process between The DCEU and the Start Layer Scanning." 
        if treatment.patient_id and treatment.start_time:
            if find_event_line('ScanningController abnormal beam detected!', line):
                data = '{}, @{}\n'.format(treatment.patient_id, parse_time(line))
                with open('AbnormalDetects.csv',"a") as f:
                    f.write(data)
                        
        # If the above if-statements have not short circuited the loop on the previous lines, it means 
        # we can look for a stop_time value in the line, which will be None until found.
        treatment.stop_time = find_event_line('Start layer scanning', line)
        if treatment.stop_time or is_cancel(line):
            treatment = Treatment()
            treatment.room = room
            
        # If all 3 values patientId, start_time, stop_time have been found add a treatment object list of treatments. 
#        if treatment.treatment_found():
#           treatments.append(treatment)
#           treatment = Treatment()
#           treatment.room = room
    return None

def is_cancel(line):
    """ A Cancel of the field has been requested by the therapists.

    Args:
        line: A line of text from the treatment process log.

    Returns:
        True if the line passed is a cancel request from the therapist.
        or
        None if it is not a Cancel request.
    """
    if re.search('Canceling layer requested', line) is not None:
        return True

def find_event_line(search_string, line):
    """ Search for a specific string to determine if a event is happening.
    
    Args:
        search_string:  A python regex expression to find an event in a file.
        line: A line of text from the treatment proccess log. 
         
    Returns:
        A datetime object representing when the event happened or None.
    """
    if re.search(search_string, line) is not None:
        start_time = parse_time(line)
        return start_time

def parse_patient_id(line):
    """ Find a patient ID in a line of text from the pts log files.
    
    Args:
        search_string:  A python regex expression to find an event in a file.
        line: A line of text from the treatment proccess log. 
         
    Returns:
        A string containing a patient id or None.
    """
    patient_id = re.search('patientId=\d{6}', line)
    if patient_id is not None:
        first, _, pid = patient_id.group().partition('=')
        return pid

def parse_time(line):
    """ Parse the timestamp out of a line of the pts log files.
    
    Args:
        line: A line of text from the treatment proccess log. 
         
    Returns:
        A datetime object resenting the time that line happened at.
    """
    match = re.search('^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3}', line)
    if match is not None:
        return datetime.datetime.strptime(match.group(), '%Y-%m-%d %H:%M:%S,%f')

def parse_dose(line):
    """ Find the primary dose from a line in the pbsdr.
    
    Args:
        line:  
         
    Returns:
        The primary dose as a Float 
    """
    dose = re.search('primaryDose:+([+-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+))', line)
    if dose:
        label, _, value = dose.group().partition(':')
        return float(value)

def is_rpc_update(line):
    """ Determine if the line in the file is an updateRpc Dose call.
    
    Args:
        line:  
         
    Returns:
        True if the line contains the RpcUpdate Dose call or None.
    """
    if re.search('beamlineId:1, mapId:', line) is not None:
        return True

def iteration_generator(collection):
    """ Create a generator object to iterate over a collection.
    
    Args:
        collection:  Any collection object that can be iterated over.   
         
    Returns:
        A generator object that can be used to control iteration of a series of objects in a collection.
    """
    for item in collection:
        yield item

def next_item(generator):
    """ Get the next item in a generator, while surpressing the StopIteration Error and return None instead.
    
    Args:
        generator:  A generator object that will yield the objects of a collection.   
         
    Returns:
        Successive items in the list of the collection. None if the collection has completed yielding items.
    """
    try:
        item = next(generator)
        return item
    except StopIteration as e:
        return None

def parse_pbsdr_file(file, fields):
    """ Parse a pbsdr file for Dose between a treatment start time / stop time.
    
    Args:
        file:  A PBSDR log file
        fields: A list of treatment objects.   
         
    Returns:
        None ,  but prints out a Common separated list of fields and doses that are over the threshold of 5E-9 electronic charge. 
    """
    field_generator = iteration_generator(fields)
    field = next_item(field_generator)
    if field is None:
        return

    first = maximum = first_time = maximum_time = None
    for raw_line in file:
        line = raw_line.decode('utf-8','strict')
        if is_rpc_update(line):
            line_time = parse_time(line)
            if field.start_time < line_time < field.stop_time:
                if first is None:
                    first = parse_dose(line)
                    first_time = line_time
                    maximum = first
                else:
                    primary_dose = parse_dose(line)
                    if primary_dose and primary_dose > maximum:
                        maximum = primary_dose
                        maximum_time = line_time
                        
            if line_time > field.stop_time and first and maximum:
                if first is not None and maximum is not None:
                    total_dose = float(maximum - first)
                    if total_dose > float('5.0E-9'):
                        data = '{}, {}, {}, {}, {}, {}, {}\n'.format(field.patient_id, first_time, first, maximum_time, maximum, total_dose, total_dose / (maximum_time - first_time).total_seconds())
                        print(data)
                first = maximum = first_time = None
                field = next_item(field_generator)
                if field is None:
                    return

def main(directory):
    """ Main program flow that will take a path to the directory containing OUTPUT.tar.gz files
    and parse them. First by finding the time when each treatment started and the time the first layer
    is started for a field. It then calculates the dose delivered in this time and outputs it to a csv file.

    Args:
        directory: Path that contains all Output.tar.gz files for a site.

    Returns:
        None
    """
    treatments = []
    room = 2
    for zipped_tarballs in find_tar_gz_files(directory):
        for tarball in find_tar_files_in_tarball(zipped_tarballs):
            with tarfile.open(fileobj=tarball) as f:  # This loops through each tar.gz file
                # Parse each treatment process room log and add to treatments
                treatment_logs = iteration_generator(find_process_log_file(f,'^pts-treat-proc-{}'.format(room)))
                for log in treatment_logs: # We must parse all treatment logs found, in case of room restarts.
                    parse_treatment_file(log, room)
 #                   treatments.extend(parse_treatment_file(log, room))  # Use extend on list so as not to create list of lists.               
                # Take all treatments found and find the dose for each from PBSDR log
#               pbsdr_logs = find_process_log_file(f,'^pts-data-recorder-pbs--')
#               for log in pbsdr_logs: # We must parse all pbsdr logs found, in case of pbsdr restart.
#                   parse_pbsdr_file(log, treatments)
                # Reset the treatments after each tar file is parsed.
#                treatments = [] 

#if __name__ == '__main__':
#    main(sys.argv[1])

main('H:\\data' )